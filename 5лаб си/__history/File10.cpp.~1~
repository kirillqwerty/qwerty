#include <iostream>
#include <new>
#include <ctime>
#include <windows.h>
#include <conio.h>

using namespace std;

// Динамическая структура данных "очередь"
template <typename T>
class Queue
{
private:
  T* p; // динамический массив
  int count; // количество элементов в очереди

public:
  // конструктор по умолчанию
  Queue()
  {
	count = 0; // очередь пустая
  }

  // конструктор копирования
  Queue(const Queue& obj)
  {
	// скопировать obj в текущий объект
	count = obj.count;

	try
	{
	  // попытка выделить память для p
	  p = new T[count];
	  // заполнить значениями
	  for (int i = 0; i < count; i++)
		p[i] = obj.p[i];
	}
	catch (bad_alloc e)
	{
	  // если память не выделена, то вывести текст ошибки
	  cout << e.what() << endl;
	  count = 0; // создать пустую очередь
	}
  }

  // добавить элемент в очередь
  void push(T item)
  {
	T* p2; // объявить дополнительный указатель
	p2 = p; // перенаправить дополнительный указатель на p

	try
	{
	  // попытка выделить новый фрагмент памяти для p, но на 1 больше
	  p = new T[count + 1];

	  // скопировать данные из участка на который указывает p2 (старые данные)
	  // в участок, на который указывает p
	  for (int i = 0; i < count; i++)
		p[i] = p2[i];

	  // скопировать последний элемент
	  p[count] = item;

	  // увеличить количество элементов на 1
	  count++;

	  // освободить предварительно выделенную память
	  if (count > 1)
		delete[] p2;
	}
	catch (bad_alloc e)
	{
	  // если память не выделена
	  cout << e.what() << endl; // вывести сообщение об ошибке

	  // вернуть старый указатель на p
	  p = p2;
	}
  }

  // вытянуть первый элемент из очереди
  T pop()
  {
	if (count == 0)
	  return 0;

	// заполнить элемент, который вытягивается из очереди
	T item;

	item = p[0];

	// сформировать новый участок памяти, который на 1 меньше
	try
	{
	  T* p2;

	  // попытка выделить пам'ять
	  p2 = new T[count - 1];

	  count--; // уменьшить количество элементов в очереди

	  // p=>p2
	  for (int i = 0; i < count; i++)
		p2[i] = p[i + 1]; // копируются все кроме первого элемента

	  // освободить участок, на который указывает p
	  if (count > 0)
		delete[] p;

	  // перенаправить p на p2
	  p = p2;

	  // вернуть item
	  return item;
	}
	catch (bad_alloc e)
	{
	  // если память не выделилась, то вернуть 0
	  cout << e.what() << endl;
	  return 0;
	}
  }

  // операторная функция operator=(),
  // реализует присваивание объектов типа Queue
  Queue& operator=(const Queue& obj)
  {
	T* p2; // указатель на дополнительную память

	try
	{
	  // попытка выделить новый участок памяти для p2
	  p2 = new T[obj.count];

	  // если память выделена успешно,
	  // можно освобождать предварительно выделенную память для p
	  if (count > 0)
		delete[] p;

	  // скопировать obj в текущий объект
	  p = p2; // перенаправить p на p2
	  count = obj.count;

	  // заполнить значениями
	  for (int i = 0; i < count; i++)
		p[i] = obj.p[i];
	}
	catch (bad_alloc e)
	{
	  // если память не выделилась, то вывести соответствующее сообщение
	  cout << e.what() << endl;
	}
	return *this; // вернуть текущий объект
  }

  // деструктор
  ~Queue()
  {
	if (count > 0)
	  delete[] p;
  }

  // количество элементов в очереди
  int GetN()
  {
	return count;
  }

  // метод, выводящий очередь
  void print(const char* objName)
  {
	cout << "\n" << objName << ": ";
	for (int i = 0; i < count; i++)
	{
		cout << p[i] << " ";
	}
	cout << endl;
  }

  // взять первый элемент из очереди не вытягивая его
  T GetItem()
  {
	if (count > 0)
	  return p[0];
	else
	  return 0;
  }

};
// Функция определения номера очереди с минимальным количеством элементов
int GetMin(int a, int b, int c, int d, int e)
{
	if (a <= b && a <= c && a <= d && a <= e)
	{
		return 1;
	}
	else if (b <= a && b <= c && b <= d && b <= e)
	{
			return 2;
	}
	else if (c <= b && c <= a && c <= d && c <= e)
	{
		return 3;
	}
	else if (d <= b && d <= c && d <= a && d <= e)
	{
		return 4;
	}
	else if (e <= b && e <= c && e <= a && e <= d)
	{
		return 5;
	}
	else
	return 0;
}

float Time, TotalTime = 0;
void timer()
{
	Sleep(Time = rand() % 1000 + 100);
	TotalTime += Time;
	system("cls");
}

Queue<int> cab1 , cab2, cab3, cab4, cab5;
void display()
{
 	 cab1.print("Cab1");
	 cab2.print("Cab2");
	 cab3.print("Cab3");
	 cab4.print("Cab4");
	 cab5.print("Cab5");
}

int main()
{
  srand(time(NULL));
  // Рандомное заполнение
  for (int i = 0; i < 20; i++)
  {
	display();

	switch (rand() % 5)
	{
	 case 0:
	 cab1.push(0);
	 break;

	 case 1:
	 cab2.push(0);
	 break;

	 case 2:
	 cab3.push(0);
	 break;

	 case 3:
	 cab4.push(0);
	 break;

	 case 4:
	 cab5.push(0);
	 break;
	}
	timer();
  }
 //--------------------------------------------------
 display();

 switch (GetMin(cab1.GetN(), cab2.GetN(), cab3.GetN(), cab4.GetN(), cab5.GetN()))
 {
	case 1:
	cab1.push(1);
	break;

	case 2:
	cab2.push(1);
	break;

	case 3:
	cab3.push(1);
	break;

	case 4:
	cab4.push(1);
	break;

	case 5:
	cab5.push(1);
	break;
 }
 timer();

 // Рандомное заполнение и удаление
  for (int i = 0; i < 20; i++)
  {
	 display();

	  switch (rand() % 10)
	  {
		case 0:
		cab1.push(0);
		break;

		case 1:
		cab1.pop();
		break;

		case 2:
		cab2.push(0);
		break;

		case 3:
		cab2.pop();
        break;

		case 4:
		cab3.push(0);
		break;

		case 5:
		cab3.pop();
		break;

		case 6:
		cab4.push(0);
		break;

		case 7:
		cab4.pop();
		break;

		case 8:
		cab5.push(0);
		break;

		case 9:
		cab5.pop();
		break;
	  }
	  timer();
  }//--------------------------------------------------

  display();
  cout << "\nTotalTime:" << TotalTime;
  getch();
  return 0;
}


